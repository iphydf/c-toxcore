/* SPDX-License-Identifier: GPL-3.0-or-later
 * Copyright Â© 2022-2026 The TokTok team.
 */

#ifndef _XOPEN_SOURCE
#define _XOPEN_SOURCE 600
#endif /* _XOPEN_SOURCE */

#if !defined(OS_WIN32) && (defined(_WIN32) || defined(__WIN32__) || defined(WIN32))
#define OS_WIN32
#endif /* WIN32 */

#include "os_clock.h"

#ifdef OS_WIN32
#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#endif /* OS_WIN32 */

#ifdef __APPLE__
#include <mach/clock.h>
#include <mach/mach.h>
#endif /* __APPLE__ */

#ifndef OS_WIN32
#include <sys/time.h>
#endif /* OS_WIN32 */

#include <time.h>

#include "ccompat.h"
#include "attributes.h"
#include "ccompat.h"

static uint64_t timespec_to_u64(struct timespec ts)
{
    return UINT64_C(1000) * ts.tv_sec + (ts.tv_nsec / UINT64_C(1000000));
}

#ifdef OS_WIN32
static uint64_t os_monotonic_ms(void *_Nullable self)
{
    LARGE_INTEGER freq;
    LARGE_INTEGER count;

    if (!QueryPerformanceFrequency(&freq)) {
        return 0;
    }

    if (!QueryPerformanceCounter(&count)) {
        return 0;
    }

    struct timespec sp = {0};
    sp.tv_sec = count.QuadPart / freq.QuadPart;

    if (freq.QuadPart < 1000000000) {
        sp.tv_nsec = (count.QuadPart % freq.QuadPart) * 1000000000 / freq.QuadPart;
    } else {
        sp.tv_nsec = (long)((count.QuadPart % freq.QuadPart) * (1000000000.0 / freq.QuadPart));
    }

    return timespec_to_u64(sp);
}

static uint64_t os_real_ms(void *_Nullable self)
{
    FILETIME ft;
    GetSystemTimeAsFileTime(&ft);
    const uint64_t t = ((uint64_t)ft.dwHighDateTime << 32) | ft.dwLowDateTime;
    /* Convert from 100-nanosecond intervals since Jan 1, 1601 to milliseconds since Jan 1, 1970. */
    return (t - UINT64_C(116444736000000000)) / 10000;
}
#else
#ifdef __APPLE__
static uint64_t os_monotonic_ms(void *_Nullable self)
{
    struct timespec clock_mono;
    clock_serv_t muhclock;
    mach_timespec_t machtime;

    host_get_clock_service(mach_host_self(), SYSTEM_CLOCK, &muhclock);
    clock_get_time(muhclock, &machtime);
    mach_port_deallocate(mach_task_self(), muhclock);

    clock_mono.tv_sec = machtime.tv_sec;
    clock_mono.tv_nsec = machtime.tv_nsec;
    return timespec_to_u64(clock_mono);
}
#else /* !__APPLE__ */
static uint64_t os_monotonic_ms(void *_Nullable self)
{
    struct timespec clock_mono;
    clock_gettime(CLOCK_MONOTONIC, &clock_mono);
    return timespec_to_u64(clock_mono);
}
#endif /* !__APPLE__ */

static uint64_t os_real_ms(void *_Nullable self)
{
#ifdef __APPLE__
    struct timespec clock_real;
    clock_serv_t muhclock;
    mach_timespec_t machtime;

    host_get_clock_service(mach_host_self(), CALENDAR_CLOCK, &muhclock);
    clock_get_time(muhclock, &machtime);
    mach_port_deallocate(mach_task_self(), muhclock);

    clock_real.tv_sec = machtime.tv_sec;
    clock_real.tv_nsec = machtime.tv_nsec;
    return timespec_to_u64(clock_real);
#else /* !__APPLE__ */
    struct timespec clock_real;
    clock_gettime(CLOCK_REALTIME, &clock_real);
    return timespec_to_u64(clock_real);
#endif /* !__APPLE__ */
}
#endif /* !OS_WIN32 */

static const Clock_Funcs os_clock_funcs = {
    os_monotonic_ms,
    os_real_ms,
    nullptr,
};

const Clock os_clock_obj = {&os_clock_funcs, nullptr};

const Clock *os_clock(void)
{
    return &os_clock_obj;
}
